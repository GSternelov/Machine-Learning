---
title: "Introduction to Machine Learning - Lab 5"
author: "Gustav Sternel√∂v"
date: "Sunday, November 15, 2015"
output:
  pdf_document:
    fig_height: 4
    fig_width: 7
---

# Assignment 1
The studied data set contains information about the mortality rate for fruit flies for each day. The data comes from a study where the theory that the mortality rates (probability of dying per unit time) of many organisms increase at an exponential rate was tested.
```{r, echo=FALSE}
mrt_rate <- read.csv("C:/Users/Gustav/Documents/Machine-Learning/Lab 5/mortality_rate.csv", sep=";")

```

## 1.1
The variable LMR, that is the logarithm of the variable Rate, is created and plotted against the variable Day.  

```{r, echo=FALSE, warning=FALSE}
library(ggplot2)
mrt_rate$LMR <- log(mrt_rate$Rate)
ggplot(mrt_rate, aes(y=LMR, x=Day)) + geom_point()
```

## 1.2 - 1.3

```{r, echo=FALSE}
# 1.2
NadWat <- function(X, Y, Xtest, lambda){
  # Wants to go through all x for every Xtest
  # Compute the value for every run and sum the 136 values
  # Do this for every value in xtest
  NdaWat <- 0
  K <- 0
  h <- 0
  for (i in 1:length(Xtest)){ 
    for (j in 1:length(X)){
     if(abs(X[j]-Xtest[i]) < lambda ){
       K[j] <- 3/4 * (1 - (abs(X[j] - Xtest[i]) / lambda)^2)
     }else{
       K[j] <- 0
     }
    }
    h <- h+1
   NdaWat[h] <- sum(K*Y) / sum(K)
  }
  return(NdaWat)
}
```


### a)

```{r, echo=FALSE}
# a) A very smooth curve
tryA <- NadWat(mrt_rate$Day, mrt_rate$LMR, mrt_rate$Day, 150)
plot(mrt_rate$Day, mrt_rate$LMR, pch=21, bg="orange")
points(tryA, x=mrt_rate$Day, type="l", lwd=5)
MSEA <- sum((mrt_rate$LMR - tryA)^2 / 136)
MSEA
```

### b)

```{r, echo=FALSE}
# b) A wiggly curve
tryB <- NadWat(mrt_rate$Day, mrt_rate$LMR, mrt_rate$Day,3)
plot(mrt_rate$Day, mrt_rate$LMR, pch=21, bg="orange")
points(tryB, x=mrt_rate$Day, type="l", lwd=5)
MSEB <- sum((mrt_rate$LMR - tryB)^2 / 136)
MSEB
```

### c)

```{r, echo=FALSE}
# c) A good fit
tryC <- NadWat(mrt_rate$Day, mrt_rate$LMR, mrt_rate$Day,8)
plot(mrt_rate$Day, mrt_rate$LMR, pch=21, bg="orange")
points(tryC, x=mrt_rate$Day, type="l", lwd=5)
MSEC <- sum((mrt_rate$LMR - tryC)^2 / 136)
MSEC
```

## 1.4
```{r, echo=FALSE}
library(kernlab)
set.seed(12345)
epsi <- seq(0.1, 3.5, 0.2)
j <- 1
MSE_SVM <- 0
for(i in epsi){
  LMR_SVM <- ksvm(LMR ~ Day, mrt_rate, type="eps-svr", 
                  kernel="rbfdot", epsilon=i)
  MSE_SVM[j] <- sum(((LMR_SVM@fitted - mrt_rate$LMR)^2)/ 136)
  j <- j+1
}

plot(epsi, MSE_SVM, type="b", pch=21, bg="orange")
# Compares original and fitted values, epsilion =2.3
LMR_SVM <- ksvm(LMR ~ Day, mrt_rate, type="eps-svr", 
                kernel="rbfdot", epsilon=2.3)

fittedV <- data.frame(LMR=LMR_SVM@fitted)
originalV <- data.frame(LMR=mrt_rate$LMR)
ValuSVM <- cbind(rbind(originalV, fittedV),Type=c(rep("OrigV", 136), rep("FittedV", 136)), Day=mrt_rate$Day)
ggplot(ValuSVM, aes(y=LMR, x=Day)) + geom_point(aes(col=Type))

MSE_SVM <- sum((originalV - fittedV)^2 / length(fittedV))

plot(mrt_rate$Day, mrt_rate$LMR, pch=21, bg="orange")
points(tryA, x=mrt_rate$Day, type="l", lwd=3, col="blue")
points(tryB, x=mrt_rate$Day, type="l", lwd=3, col="steelblue")
points(tryC, x=mrt_rate$Day, type="l", lwd=3, col="darkblue")
points(fittedV[,1], x=mrt_rate$Day, type="l", lwd=3, col="seagreen")
legend(120,-4,c("1.3a","1.3b", "1.3c", "1.4"), lty=c(1,1), 
       lwd=c(2.5,2.5),col=c("blue","steelblue", "darkblue", "seagreen"),  cex=0.6) 

```


## 1.5

```{r, echo=FALSE, message=FALSE}
library(fANCOVA)
loessLMR <- loess.as(mrt_rate$Day, mrt_rate$LMR, 1, family = "gaussian", plot=FALSE, 
                     criterion="gcv")
predLoess <- predict(loessLMR, se=TRUE)
upper <- predLoess$fit + predLoess$se.fit * 2
lower <- predLoess$fit - predLoess$se.fit * 2
plot(loessLMR, type="l")
points(loessLMR$x, upper, type="l", col="orange")
points(loessLMR$x, lower, type="l" ,col="orange")
```


# Assignment 2
The data set analysed in this assignment consists of information about 572 italian olive oils coming from different regions of the country. How much of different acids each olive oil contains and from which region and area the olive oil comes from is the information given. 
```{r, echo=FALSE, message=FALSE, warning=FALSE}
olive <- read.csv("C:/Users/Gustav/Documents/Machine-Learning/Lab 5/olive.csv", sep=",")
library(kernlab)
```

## 2.1
Two of the acids in the data set are *Oleic* and *Linoleic*. In the following graph these acids are plotted against each other and coloured after region where oils from region two are light blue and the others are dark blue.

```{r, echo=FALSE}
olive$R2 <- 0
for (i in 1:572){
  if(olive$Region[i] == 2){
    olive$R2[i] = 1
  }else{
    olive$R2[i] = 0
  }
}
ggplot(olive, aes(x=linoleic, y=oleic)) + geom_point(aes(col=R2))

```
The oils from region two are quite easy to identify since they lies rather separately from oils from the other regions. At least that is true for the majority of the observations from region two. Some of the dark blue points lies very close to the outer edges of the group of light blue points.  For these observations it may be hard for a model to correctly classify an olive oil as coming from region two or from one of the other regions. 

## 2.2
```{r, echo=FALSE}
set.seed(12345)
```

### a)

```{r, echo=FALSE, include=FALSE}
linearSVM <- ksvm(R2 ~ oleic+linoleic, olive, type="C-svc", kernel="vanilladot")
```

```{r, echo=FALSE}
plot(linearSVM, data=olive)
```

The misclassification rate: `r linearSVM@error`  
The amount of support vectors: `r linearSVM@nSV`

### b)

```{r, echo=FALSE}
rbfSVM <- ksvm(R2 ~ oleic+linoleic, olive, type="C-svc", 
               kernel="rbfdot")
plot(rbfSVM, data=olive)
```
The misclassification rate: `r rbfSVM@error`  
The amount of support vectors: `r rbfSVM@nSV`

### c)

```{r, echo=FALSE}
rbf_penSVM <- ksvm(R2 ~ oleic+linoleic, olive, type="C-svc", 
               kernel="rbfdot", C=100)
plot(rbf_penSVM, data=olive)
```
The misclassification rate: `r rbf_penSVM@error`  
The amount of support vectors: `r rbf_penSVM@nSV`

### d)

```{r, echo=FALSE}
rbf_bwitdhSVM <- ksvm(R2 ~ oleic+linoleic, olive, type="C-svc", 
                   kernel="rbfdot", kpar=list(sigma=10))
plot(rbf_bwitdhSVM, data=olive)
```

The misclassification rate: `r rbf_bwitdhSVM@error`  
The amount of support vectors: `r rbf_bwitdhSVM@nSV`

### Comparison of models
In terms of misclassification rate model *c*, the model with RBF kernel and penalty for C equal to 100, seem to be the best. It has the lowest misclassification rate, even though it also should be mentioned that the difference between the misclassification rates for the models is very small.  

How does the parameters chosen in *c* and *d* influence the classification? The value of C defines the cost of constraints violation.   

The amount of support vectors in the models differs significantly. In model *a* and in model *d* 119 of the 572 observated values are used as support vectors. Less than a half of this amount of support vectors are used in model *b*, 52, and in model *c* 15 values are used as support vectors.  


## 2.3

```{r, echo=FALSE, include=FALSE}
olive_acid <- olive[, c(2, 4:11)]
rbf_spocSVM <- ksvm(Region ~. , olive, type="spoc-svc", 
                      kernel="vanilladot", cross=10)
```

The misclassification rate: `r rbf_spocSVM@error`  
The amount of support vectors: `r rbf_spocSVM@nSV`

How do I find the cross-validation score?
